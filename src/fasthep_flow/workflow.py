"""Workflow and Task classes to define and execute a compute graph."""

from __future__ import annotations

import hashlib
import inspect
import pickle
import shutil
import string
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

import dill

from .config import FlowConfig

REPLACE_DICT = {ord(c): "_" for c in string.whitespace + string.punctuation}
REPLACE_TABLE = str.maketrans(REPLACE_DICT)


@dataclass
class Task:
    """Wrapper for any compute task implementation we want to support."""

    name: str
    type: str
    kwargs: dict[str, Any]
    payload: Any

    def __call__(self) -> Any:
        return self.payload()

    @property
    def safe_name(self) -> str:
        """Return a safe name for the task."""
        return self.name.translate(REPLACE_TABLE)


def get_object_source(obj: Any, task_name: str) -> str:
    # Capture the object definition
    obj_attrs = {}

    for attr_name, attr_value in inspect.getmembers(obj):
        if not attr_name.startswith("__") and not inspect.isroutine(attr_value):
            obj_attrs[attr_name] = attr_value

    # Return the object definition as source code string
    task_base_source = dill.source.getsource(Task)
    task_source = dill.source.getsource(obj, alias=task_name)

    return str(task_source.replace(task_base_source, "").strip())


def get_config_hash(config_file: Path) -> str:
    with config_file.open("rb") as f:
        return hashlib.file_digest(f, "sha256").hexdigest()[:8]


def create_save_path(base_path: Path, workflow_name: str, config_hash: str) -> Path:
    date = datetime.now().strftime("%Y.%m.%d")
    path = Path(f"{base_path}/{workflow_name}/{date}/{config_hash}/").resolve()
    path.mkdir(parents=True, exist_ok=True)
    return path


@dataclass
class Workflow:
    """Wrapper for any compute graph implementation we want to support."""

    config: FlowConfig
    tasks: list[Task]  # TODO: Maybe this should be an OrderedDict
    name: str = "fasthep-flow"

    def __init__(self, config: FlowConfig) -> None:
        self.config = config
        tasks = config.tasks
        self.tasks = []
        self.name = config.metadata.get("name", self.name)
        for task in tasks:
            self.tasks.append(
                Task(
                    name=task.name,
                    type=task.type,
                    kwargs=task.kwargs if task.kwargs is not None else {},
                    payload=task.resolve() if hasattr(task, "resolve") else None,
                    # TODO: pass information about the task's dependencies and execution environment
                )
            )

    def __call__(self) -> Any:
        """Function to execute all tasks in the workflow."""
        for task in self.tasks:
            yield task.payload()

    def run(self) -> Any:
        """Function to execute all tasks in the workflow."""
        return list(self())

    def _save_tasks(self, task_file: Path) -> None:
        imports = [str(sys.modules[__name__].__name__) + ".Task"]
        task_definitions = []
        for task in self.tasks:
            task_name = task.safe_name
            task_definitions.append(get_object_source(task, task_name))
            imports.append(task.type)
        with task_file.open("w") as f:
            f.write("# This file was generated by fasthep-flow\n")
            for imp in set(imports):
                module_path, class_name = imp.rsplit(".", 1)
                f.write(f"from {module_path} import {class_name}\n")
            f.write("\n\n")
            for task_def in task_definitions:
                f.write(task_def + "\n\n")

    def save(self, base_path: Path = Path("~/.fasthep/flow)")) -> None:
        """
        Save the workflow to a file.
        Automatic path is ~/.fasthep/flow/{workflow_name}/{datetime}/{config_hash}/
        """
        config_file = Path(self.config.config_file)
        config_hash = get_config_hash(config_file)
        path = create_save_path(base_path, self.name, config_hash)
        # copy the config file to the path
        shutil.copy(config_file, path / config_file.name)
        # save the workflow to the path
        workflow_file = path / "workflow.pkl"
        with workflow_file.open("wb") as f:
            pickle.dump(self, f)
        # store the python code for each task in tasks.py
        task_file = path / "tasks.py"
        self._save_tasks(task_file)
